// Generated by gencpp from file lcm_to_ros/can_modulo_estado.msg
// DO NOT EDIT!


#ifndef LCM_TO_ROS_MESSAGE_CAN_MODULO_ESTADO_H
#define LCM_TO_ROS_MESSAGE_CAN_MODULO_ESTADO_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace lcm_to_ros
{
template <class ContainerAllocator>
struct can_modulo_estado_
{
  typedef can_modulo_estado_<ContainerAllocator> Type;

  can_modulo_estado_()
    : Timestamp_sec(0)
    , Timestamp_nsec(0)
    , IdModulo(0)
    , InputVolA(0.0)
    , InputVolB(0.0)
    , InputCorrA(0.0)
    , InputCorrB(0.0)
    , OutputAnlg1(0.0)
    , OutputAnlg2(0.0)
    , InputDig1(false)
    , InputDig2(false)
    , InputDig3(false)
    , InputDig4(false)
    , OutputDig1(false)
    , OutputDig2(false)
    , OutputDig3(false)
    , OutputDig4(false)
    , OutputDig5(false)
    , OutputDig6(false)
    , OutputDig7(false)
    , OutputDig8(false)  {
    }
  can_modulo_estado_(const ContainerAllocator& _alloc)
    : Timestamp_sec(0)
    , Timestamp_nsec(0)
    , IdModulo(0)
    , InputVolA(0.0)
    , InputVolB(0.0)
    , InputCorrA(0.0)
    , InputCorrB(0.0)
    , OutputAnlg1(0.0)
    , OutputAnlg2(0.0)
    , InputDig1(false)
    , InputDig2(false)
    , InputDig3(false)
    , InputDig4(false)
    , OutputDig1(false)
    , OutputDig2(false)
    , OutputDig3(false)
    , OutputDig4(false)
    , OutputDig5(false)
    , OutputDig6(false)
    , OutputDig7(false)
    , OutputDig8(false)  {
  (void)_alloc;
    }



   typedef int32_t _Timestamp_sec_type;
  _Timestamp_sec_type Timestamp_sec;

   typedef int32_t _Timestamp_nsec_type;
  _Timestamp_nsec_type Timestamp_nsec;

   typedef int8_t _IdModulo_type;
  _IdModulo_type IdModulo;

   typedef double _InputVolA_type;
  _InputVolA_type InputVolA;

   typedef double _InputVolB_type;
  _InputVolB_type InputVolB;

   typedef double _InputCorrA_type;
  _InputCorrA_type InputCorrA;

   typedef double _InputCorrB_type;
  _InputCorrB_type InputCorrB;

   typedef double _OutputAnlg1_type;
  _OutputAnlg1_type OutputAnlg1;

   typedef double _OutputAnlg2_type;
  _OutputAnlg2_type OutputAnlg2;

   typedef uint8_t _InputDig1_type;
  _InputDig1_type InputDig1;

   typedef uint8_t _InputDig2_type;
  _InputDig2_type InputDig2;

   typedef uint8_t _InputDig3_type;
  _InputDig3_type InputDig3;

   typedef uint8_t _InputDig4_type;
  _InputDig4_type InputDig4;

   typedef uint8_t _OutputDig1_type;
  _OutputDig1_type OutputDig1;

   typedef uint8_t _OutputDig2_type;
  _OutputDig2_type OutputDig2;

   typedef uint8_t _OutputDig3_type;
  _OutputDig3_type OutputDig3;

   typedef uint8_t _OutputDig4_type;
  _OutputDig4_type OutputDig4;

   typedef uint8_t _OutputDig5_type;
  _OutputDig5_type OutputDig5;

   typedef uint8_t _OutputDig6_type;
  _OutputDig6_type OutputDig6;

   typedef uint8_t _OutputDig7_type;
  _OutputDig7_type OutputDig7;

   typedef uint8_t _OutputDig8_type;
  _OutputDig8_type OutputDig8;





  typedef boost::shared_ptr< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> const> ConstPtr;

}; // struct can_modulo_estado_

typedef ::lcm_to_ros::can_modulo_estado_<std::allocator<void> > can_modulo_estado;

typedef boost::shared_ptr< ::lcm_to_ros::can_modulo_estado > can_modulo_estadoPtr;
typedef boost::shared_ptr< ::lcm_to_ros::can_modulo_estado const> can_modulo_estadoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace lcm_to_ros

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'lcm_to_ros': ['/home/alberto/workspaces/workspace14diciembre/src/lcm_to_ros/msg'], 'std_msgs': ['/opt/ros/melodic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
{
  static const char* value()
  {
    return "e6f65a6fba4df534967c07b0198c1dba";
  }

  static const char* value(const ::lcm_to_ros::can_modulo_estado_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xe6f65a6fba4df534ULL;
  static const uint64_t static_value2 = 0x967c07b0198c1dbaULL;
};

template<class ContainerAllocator>
struct DataType< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
{
  static const char* value()
  {
    return "lcm_to_ros/can_modulo_estado";
  }

  static const char* value(const ::lcm_to_ros::can_modulo_estado_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#######################################################################\n\
# This message was automatically generated by the lcm_to_ros package\n\
# https://github.com/nrjl/lcm_to_ros, nicholas.lawrance@oregonstate.edu\n\
#######################################################################\n\
#\n\
# Source message:    .msg\n\
# Creation:          lun 18 feb 2019 17:14:16 CET\n\
#\n\
#######################################################################\n\
int32               Timestamp_sec\n\
int32               Timestamp_nsec\n\
byte                IdModulo\n\
float64             InputVolA\n\
float64             InputVolB\n\
float64             InputCorrA\n\
float64             InputCorrB\n\
float64             OutputAnlg1\n\
float64             OutputAnlg2\n\
bool                InputDig1\n\
bool                InputDig2\n\
bool                InputDig3\n\
bool                InputDig4\n\
bool                OutputDig1\n\
bool                OutputDig2\n\
bool                OutputDig3\n\
bool                OutputDig4\n\
bool                OutputDig5\n\
bool                OutputDig6\n\
bool                OutputDig7\n\
bool                OutputDig8\n\
";
  }

  static const char* value(const ::lcm_to_ros::can_modulo_estado_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.Timestamp_sec);
      stream.next(m.Timestamp_nsec);
      stream.next(m.IdModulo);
      stream.next(m.InputVolA);
      stream.next(m.InputVolB);
      stream.next(m.InputCorrA);
      stream.next(m.InputCorrB);
      stream.next(m.OutputAnlg1);
      stream.next(m.OutputAnlg2);
      stream.next(m.InputDig1);
      stream.next(m.InputDig2);
      stream.next(m.InputDig3);
      stream.next(m.InputDig4);
      stream.next(m.OutputDig1);
      stream.next(m.OutputDig2);
      stream.next(m.OutputDig3);
      stream.next(m.OutputDig4);
      stream.next(m.OutputDig5);
      stream.next(m.OutputDig6);
      stream.next(m.OutputDig7);
      stream.next(m.OutputDig8);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct can_modulo_estado_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::lcm_to_ros::can_modulo_estado_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::lcm_to_ros::can_modulo_estado_<ContainerAllocator>& v)
  {
    s << indent << "Timestamp_sec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Timestamp_sec);
    s << indent << "Timestamp_nsec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Timestamp_nsec);
    s << indent << "IdModulo: ";
    Printer<int8_t>::stream(s, indent + "  ", v.IdModulo);
    s << indent << "InputVolA: ";
    Printer<double>::stream(s, indent + "  ", v.InputVolA);
    s << indent << "InputVolB: ";
    Printer<double>::stream(s, indent + "  ", v.InputVolB);
    s << indent << "InputCorrA: ";
    Printer<double>::stream(s, indent + "  ", v.InputCorrA);
    s << indent << "InputCorrB: ";
    Printer<double>::stream(s, indent + "  ", v.InputCorrB);
    s << indent << "OutputAnlg1: ";
    Printer<double>::stream(s, indent + "  ", v.OutputAnlg1);
    s << indent << "OutputAnlg2: ";
    Printer<double>::stream(s, indent + "  ", v.OutputAnlg2);
    s << indent << "InputDig1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.InputDig1);
    s << indent << "InputDig2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.InputDig2);
    s << indent << "InputDig3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.InputDig3);
    s << indent << "InputDig4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.InputDig4);
    s << indent << "OutputDig1: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig1);
    s << indent << "OutputDig2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig2);
    s << indent << "OutputDig3: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig3);
    s << indent << "OutputDig4: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig4);
    s << indent << "OutputDig5: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig5);
    s << indent << "OutputDig6: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig6);
    s << indent << "OutputDig7: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig7);
    s << indent << "OutputDig8: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.OutputDig8);
  }
};

} // namespace message_operations
} // namespace ros

#endif // LCM_TO_ROS_MESSAGE_CAN_MODULO_ESTADO_H
