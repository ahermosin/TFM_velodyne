// Generated by gencpp from file lcm_to_ros/imu_all.msg
// DO NOT EDIT!


#ifndef LCM_TO_ROS_MESSAGE_IMU_ALL_H
#define LCM_TO_ROS_MESSAGE_IMU_ALL_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace lcm_to_ros
{
template <class ContainerAllocator>
struct imu_all_
{
  typedef imu_all_<ContainerAllocator> Type;

  imu_all_()
    : Timestamp_sec(0)
    , Timestamp_nsec(0)
    , Roll(0.0)
    , Pitch(0.0)
    , Yaw(0.0)
    , Wx(0.0)
    , Wy(0.0)
    , Wz(0.0)
    , AcelX(0.0)
    , AcelY(0.0)
    , AcelZ(0.0)
    , VelN(0.0)
    , VelE(0.0)
    , VelZ(0.0)
    , GPSLong(0.0)
    , GPSLat(0.0)
    , GPSAlt(0.0)
    , Temp(0.0)
    , IMUTime(0)
    , BITStatus(0)  {
    }
  imu_all_(const ContainerAllocator& _alloc)
    : Timestamp_sec(0)
    , Timestamp_nsec(0)
    , Roll(0.0)
    , Pitch(0.0)
    , Yaw(0.0)
    , Wx(0.0)
    , Wy(0.0)
    , Wz(0.0)
    , AcelX(0.0)
    , AcelY(0.0)
    , AcelZ(0.0)
    , VelN(0.0)
    , VelE(0.0)
    , VelZ(0.0)
    , GPSLong(0.0)
    , GPSLat(0.0)
    , GPSAlt(0.0)
    , Temp(0.0)
    , IMUTime(0)
    , BITStatus(0)  {
  (void)_alloc;
    }



   typedef int32_t _Timestamp_sec_type;
  _Timestamp_sec_type Timestamp_sec;

   typedef int32_t _Timestamp_nsec_type;
  _Timestamp_nsec_type Timestamp_nsec;

   typedef double _Roll_type;
  _Roll_type Roll;

   typedef double _Pitch_type;
  _Pitch_type Pitch;

   typedef double _Yaw_type;
  _Yaw_type Yaw;

   typedef double _Wx_type;
  _Wx_type Wx;

   typedef double _Wy_type;
  _Wy_type Wy;

   typedef double _Wz_type;
  _Wz_type Wz;

   typedef double _AcelX_type;
  _AcelX_type AcelX;

   typedef double _AcelY_type;
  _AcelY_type AcelY;

   typedef double _AcelZ_type;
  _AcelZ_type AcelZ;

   typedef double _VelN_type;
  _VelN_type VelN;

   typedef double _VelE_type;
  _VelE_type VelE;

   typedef double _VelZ_type;
  _VelZ_type VelZ;

   typedef double _GPSLong_type;
  _GPSLong_type GPSLong;

   typedef double _GPSLat_type;
  _GPSLat_type GPSLat;

   typedef double _GPSAlt_type;
  _GPSAlt_type GPSAlt;

   typedef double _Temp_type;
  _Temp_type Temp;

   typedef int32_t _IMUTime_type;
  _IMUTime_type IMUTime;

   typedef int16_t _BITStatus_type;
  _BITStatus_type BITStatus;





  typedef boost::shared_ptr< ::lcm_to_ros::imu_all_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::lcm_to_ros::imu_all_<ContainerAllocator> const> ConstPtr;

}; // struct imu_all_

typedef ::lcm_to_ros::imu_all_<std::allocator<void> > imu_all;

typedef boost::shared_ptr< ::lcm_to_ros::imu_all > imu_allPtr;
typedef boost::shared_ptr< ::lcm_to_ros::imu_all const> imu_allConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::lcm_to_ros::imu_all_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::lcm_to_ros::imu_all_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace lcm_to_ros

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'lcm_to_ros': ['/home/alberto/workspaces/workspace14diciembre/src/lcm_to_ros/msg'], 'std_msgs': ['/opt/ros/melodic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::imu_all_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::imu_all_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::imu_all_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::imu_all_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::imu_all_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::imu_all_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::lcm_to_ros::imu_all_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ec9945e7705b83f3d7cbfa676d070663";
  }

  static const char* value(const ::lcm_to_ros::imu_all_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xec9945e7705b83f3ULL;
  static const uint64_t static_value2 = 0xd7cbfa676d070663ULL;
};

template<class ContainerAllocator>
struct DataType< ::lcm_to_ros::imu_all_<ContainerAllocator> >
{
  static const char* value()
  {
    return "lcm_to_ros/imu_all";
  }

  static const char* value(const ::lcm_to_ros::imu_all_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::lcm_to_ros::imu_all_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#######################################################################\n\
# This message was automatically generated by the lcm_to_ros package\n\
# https://github.com/nrjl/lcm_to_ros, nicholas.lawrance@oregonstate.edu\n\
#######################################################################\n\
#\n\
# Source message:    .msg\n\
# Creation:          lun 18 feb 2019 17:14:16 CET\n\
#\n\
#######################################################################\n\
int32               Timestamp_sec\n\
int32               Timestamp_nsec\n\
float64             Roll\n\
float64             Pitch\n\
float64             Yaw\n\
float64             Wx\n\
float64             Wy\n\
float64             Wz\n\
float64             AcelX\n\
float64             AcelY\n\
float64             AcelZ\n\
float64             VelN\n\
float64             VelE\n\
float64             VelZ\n\
float64             GPSLong\n\
float64             GPSLat\n\
float64             GPSAlt\n\
float64             Temp\n\
int32               IMUTime\n\
int16               BITStatus\n\
";
  }

  static const char* value(const ::lcm_to_ros::imu_all_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::lcm_to_ros::imu_all_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.Timestamp_sec);
      stream.next(m.Timestamp_nsec);
      stream.next(m.Roll);
      stream.next(m.Pitch);
      stream.next(m.Yaw);
      stream.next(m.Wx);
      stream.next(m.Wy);
      stream.next(m.Wz);
      stream.next(m.AcelX);
      stream.next(m.AcelY);
      stream.next(m.AcelZ);
      stream.next(m.VelN);
      stream.next(m.VelE);
      stream.next(m.VelZ);
      stream.next(m.GPSLong);
      stream.next(m.GPSLat);
      stream.next(m.GPSAlt);
      stream.next(m.Temp);
      stream.next(m.IMUTime);
      stream.next(m.BITStatus);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct imu_all_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::lcm_to_ros::imu_all_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::lcm_to_ros::imu_all_<ContainerAllocator>& v)
  {
    s << indent << "Timestamp_sec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Timestamp_sec);
    s << indent << "Timestamp_nsec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.Timestamp_nsec);
    s << indent << "Roll: ";
    Printer<double>::stream(s, indent + "  ", v.Roll);
    s << indent << "Pitch: ";
    Printer<double>::stream(s, indent + "  ", v.Pitch);
    s << indent << "Yaw: ";
    Printer<double>::stream(s, indent + "  ", v.Yaw);
    s << indent << "Wx: ";
    Printer<double>::stream(s, indent + "  ", v.Wx);
    s << indent << "Wy: ";
    Printer<double>::stream(s, indent + "  ", v.Wy);
    s << indent << "Wz: ";
    Printer<double>::stream(s, indent + "  ", v.Wz);
    s << indent << "AcelX: ";
    Printer<double>::stream(s, indent + "  ", v.AcelX);
    s << indent << "AcelY: ";
    Printer<double>::stream(s, indent + "  ", v.AcelY);
    s << indent << "AcelZ: ";
    Printer<double>::stream(s, indent + "  ", v.AcelZ);
    s << indent << "VelN: ";
    Printer<double>::stream(s, indent + "  ", v.VelN);
    s << indent << "VelE: ";
    Printer<double>::stream(s, indent + "  ", v.VelE);
    s << indent << "VelZ: ";
    Printer<double>::stream(s, indent + "  ", v.VelZ);
    s << indent << "GPSLong: ";
    Printer<double>::stream(s, indent + "  ", v.GPSLong);
    s << indent << "GPSLat: ";
    Printer<double>::stream(s, indent + "  ", v.GPSLat);
    s << indent << "GPSAlt: ";
    Printer<double>::stream(s, indent + "  ", v.GPSAlt);
    s << indent << "Temp: ";
    Printer<double>::stream(s, indent + "  ", v.Temp);
    s << indent << "IMUTime: ";
    Printer<int32_t>::stream(s, indent + "  ", v.IMUTime);
    s << indent << "BITStatus: ";
    Printer<int16_t>::stream(s, indent + "  ", v.BITStatus);
  }
};

} // namespace message_operations
} // namespace ros

#endif // LCM_TO_ROS_MESSAGE_IMU_ALL_H
