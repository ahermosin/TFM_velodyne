// Generated by gencpp from file lcm_to_ros/mobileye_obstaculo.msg
// DO NOT EDIT!


#ifndef LCM_TO_ROS_MESSAGE_MOBILEYE_OBSTACULO_H
#define LCM_TO_ROS_MESSAGE_MOBILEYE_OBSTACULO_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace lcm_to_ros
{
template <class ContainerAllocator>
struct mobileye_obstaculo_
{
  typedef mobileye_obstaculo_<ContainerAllocator> Type;

  mobileye_obstaculo_()
    : timestamp_sec(0)
    , timestamp_nsec(0)
    , posicionX(0.0)
    , posicionY(0.0)
    , velocidadRel(0.0)
    , aceleracionX(0.0)
    , longitud(0.0)
    , ancho(0.0)
    , angulo(0.0)
    , angleRate(0.0)
    , scaleChange(0.0)
    , edad(0)
    , id(0)
    , tipo(0)
    , status(0)
    , carril(0)
    , flags(0)
    , intermitentes(0)
    , cutInOut(0)  {
    }
  mobileye_obstaculo_(const ContainerAllocator& _alloc)
    : timestamp_sec(0)
    , timestamp_nsec(0)
    , posicionX(0.0)
    , posicionY(0.0)
    , velocidadRel(0.0)
    , aceleracionX(0.0)
    , longitud(0.0)
    , ancho(0.0)
    , angulo(0.0)
    , angleRate(0.0)
    , scaleChange(0.0)
    , edad(0)
    , id(0)
    , tipo(0)
    , status(0)
    , carril(0)
    , flags(0)
    , intermitentes(0)
    , cutInOut(0)  {
  (void)_alloc;
    }



   typedef int32_t _timestamp_sec_type;
  _timestamp_sec_type timestamp_sec;

   typedef int32_t _timestamp_nsec_type;
  _timestamp_nsec_type timestamp_nsec;

   typedef float _posicionX_type;
  _posicionX_type posicionX;

   typedef float _posicionY_type;
  _posicionY_type posicionY;

   typedef float _velocidadRel_type;
  _velocidadRel_type velocidadRel;

   typedef float _aceleracionX_type;
  _aceleracionX_type aceleracionX;

   typedef float _longitud_type;
  _longitud_type longitud;

   typedef float _ancho_type;
  _ancho_type ancho;

   typedef float _angulo_type;
  _angulo_type angulo;

   typedef float _angleRate_type;
  _angleRate_type angleRate;

   typedef float _scaleChange_type;
  _scaleChange_type scaleChange;

   typedef int16_t _edad_type;
  _edad_type edad;

   typedef int8_t _id_type;
  _id_type id;

   typedef int8_t _tipo_type;
  _tipo_type tipo;

   typedef int8_t _status_type;
  _status_type status;

   typedef int8_t _carril_type;
  _carril_type carril;

   typedef int8_t _flags_type;
  _flags_type flags;

   typedef int8_t _intermitentes_type;
  _intermitentes_type intermitentes;

   typedef int8_t _cutInOut_type;
  _cutInOut_type cutInOut;





  typedef boost::shared_ptr< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> const> ConstPtr;

}; // struct mobileye_obstaculo_

typedef ::lcm_to_ros::mobileye_obstaculo_<std::allocator<void> > mobileye_obstaculo;

typedef boost::shared_ptr< ::lcm_to_ros::mobileye_obstaculo > mobileye_obstaculoPtr;
typedef boost::shared_ptr< ::lcm_to_ros::mobileye_obstaculo const> mobileye_obstaculoConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace lcm_to_ros

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': True, 'IsMessage': True, 'HasHeader': False}
// {'lcm_to_ros': ['/home/alberto/workspaces/workspace14diciembre/src/lcm_to_ros/msg'], 'std_msgs': ['/opt/ros/melodic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "089b186e41a459d4bb6e84f175bf79ab";
  }

  static const char* value(const ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x089b186e41a459d4ULL;
  static const uint64_t static_value2 = 0xbb6e84f175bf79abULL;
};

template<class ContainerAllocator>
struct DataType< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "lcm_to_ros/mobileye_obstaculo";
  }

  static const char* value(const ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
{
  static const char* value()
  {
    return "#######################################################################\n\
# This message was automatically generated by the lcm_to_ros package\n\
# https://github.com/nrjl/lcm_to_ros, nicholas.lawrance@oregonstate.edu\n\
#######################################################################\n\
#\n\
# Source message:    .msg\n\
# Creation:          lun 18 feb 2019 17:14:17 CET\n\
#\n\
#######################################################################\n\
int32               timestamp_sec\n\
int32               timestamp_nsec\n\
float32             posicionX\n\
float32             posicionY\n\
float32             velocidadRel\n\
float32             aceleracionX\n\
float32             longitud\n\
float32             ancho\n\
float32             angulo\n\
float32             angleRate\n\
float32             scaleChange\n\
int16               edad\n\
byte                id\n\
byte                tipo\n\
byte                status\n\
byte                carril\n\
byte                flags\n\
byte                intermitentes\n\
byte                cutInOut\n\
";
  }

  static const char* value(const ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.timestamp_sec);
      stream.next(m.timestamp_nsec);
      stream.next(m.posicionX);
      stream.next(m.posicionY);
      stream.next(m.velocidadRel);
      stream.next(m.aceleracionX);
      stream.next(m.longitud);
      stream.next(m.ancho);
      stream.next(m.angulo);
      stream.next(m.angleRate);
      stream.next(m.scaleChange);
      stream.next(m.edad);
      stream.next(m.id);
      stream.next(m.tipo);
      stream.next(m.status);
      stream.next(m.carril);
      stream.next(m.flags);
      stream.next(m.intermitentes);
      stream.next(m.cutInOut);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mobileye_obstaculo_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::lcm_to_ros::mobileye_obstaculo_<ContainerAllocator>& v)
  {
    s << indent << "timestamp_sec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.timestamp_sec);
    s << indent << "timestamp_nsec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.timestamp_nsec);
    s << indent << "posicionX: ";
    Printer<float>::stream(s, indent + "  ", v.posicionX);
    s << indent << "posicionY: ";
    Printer<float>::stream(s, indent + "  ", v.posicionY);
    s << indent << "velocidadRel: ";
    Printer<float>::stream(s, indent + "  ", v.velocidadRel);
    s << indent << "aceleracionX: ";
    Printer<float>::stream(s, indent + "  ", v.aceleracionX);
    s << indent << "longitud: ";
    Printer<float>::stream(s, indent + "  ", v.longitud);
    s << indent << "ancho: ";
    Printer<float>::stream(s, indent + "  ", v.ancho);
    s << indent << "angulo: ";
    Printer<float>::stream(s, indent + "  ", v.angulo);
    s << indent << "angleRate: ";
    Printer<float>::stream(s, indent + "  ", v.angleRate);
    s << indent << "scaleChange: ";
    Printer<float>::stream(s, indent + "  ", v.scaleChange);
    s << indent << "edad: ";
    Printer<int16_t>::stream(s, indent + "  ", v.edad);
    s << indent << "id: ";
    Printer<int8_t>::stream(s, indent + "  ", v.id);
    s << indent << "tipo: ";
    Printer<int8_t>::stream(s, indent + "  ", v.tipo);
    s << indent << "status: ";
    Printer<int8_t>::stream(s, indent + "  ", v.status);
    s << indent << "carril: ";
    Printer<int8_t>::stream(s, indent + "  ", v.carril);
    s << indent << "flags: ";
    Printer<int8_t>::stream(s, indent + "  ", v.flags);
    s << indent << "intermitentes: ";
    Printer<int8_t>::stream(s, indent + "  ", v.intermitentes);
    s << indent << "cutInOut: ";
    Printer<int8_t>::stream(s, indent + "  ", v.cutInOut);
  }
};

} // namespace message_operations
} // namespace ros

#endif // LCM_TO_ROS_MESSAGE_MOBILEYE_OBSTACULO_H
